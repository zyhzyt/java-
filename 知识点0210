当TCP 发送报文段时，就创建该特定报文段的重传计时器。可能发生两种情况：
      1.    若在计时器截止时间到之前收到了对此特定报文段的确认，则撤销此计时器。
      2.    若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。


http的八种请求方法：get,post,put,delete,head,trace,options,connect
  get用于获取资源，post用于传输实体主体，put用于传输文件, HEAD方法只是请求消息报头，而不是完整的内容


能登录QQ说明UDP没问题，能查看同事的电脑，说明DHCP协议也没问题，但是无法访问网络，原因可能是浏览器，也可能是HTTP协议，但是DNS是最基本的问题，也是最可能出现的问题


DoS攻击是; 发送无效的请求，使得正确的请求无法被响应
指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。


ping是TCP/IP协议族的一部分，其属于网络层协议。主要是用来检测网络是否通畅。如果要ping其他网段，则需要设置网关。
DNS设置错会影响访问公网服务器的域名, 而不会影响内部子设备是否ping通
ping命令是跨操作系统的, windows主机能够ping通Linux主机
二层交换机如果出现故障那么同网段主机则不会ping通


(1)路由信息组成部分：1.目的主机的网络地址 2.下一跳的地址  3.子网掩码
(2)-net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络



 OSI参考模型中，
物理层提供为建立；维护和拆除物理链路所需的机械、电气、功能和规程的特性；
数据链路层负责在两个相邻结点间的线路上，无差错地传送以帧为单位的数据，并进行流量控制；
网络层为传输层实体提供端到端的交换网络数据传送功能，使得传输层摆脱路由选择、交换方式、拥挤控制等网络传输细节。
传输层为会话层实体提供透明、可靠的数据传输服务，保证端到端的数据完整性。
网络层实现路由选择、拥塞控制和互联功能。
 


状态码分为5类，如下：
•	1××(“继续努力”) => 表示接收到请求并且继续处理 
•	2××（“开心”） => 表示动作被成功接收、理解和接受 
•	3××（“又要跑一趟”） => 为了完成指定的动作，必须接受进一步处理 
•	4××（“自己的问题自己解决”） => 客户端发生错误，请求中包含错误语法，请求不能被正确执行 
•	5××（“服务不到位”） => 服务端出现错误，服务器不能正确地执行请求


linux下etc下resolv.conf文件的作用
该文件是DNS域名解析的配置文件，它的格式很简单，每行以一个关键字开头，后接配置参数。resolv.conf的关键字主要有四个，分别是： 

nameserver   #定义DNS服务器的IP地址 
domain       #定义本地域名 
search       #定义域名的搜索列表 
sortlist     #对返回的域名进行排序 

/etc/resolv.conf的一个示例： 

domain test.com 
search www.test.com test.com 
nameserver 202.96.128.86 
nameserver 202.96.128.166 

  最主要是nameserver关键字，如果没指定nameserver就找不到DNS服务器，其它关键字是可选的。 








TCP协议的主要功能是完成对数据报的确认、流量控制和网络拥塞；自动检测数据报，并提供错误重发的功能 ；将多条路径传送的数据报按照原来的顺序进行排列，并对重复数据进行择取；控制超时重发，自动调整超时值；提供自动恢复丢失数据的功能。

除TCP功能以外需要程序员考虑的为发送数据的格式及应用层协议。









DNS劫持，意思是通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。 
DNS系统中一般有两种服务角色：递归 DNS 和授权 DNS。 
本质上来说，授权 DNS 控制网站的解析；递归 DNS 只起缓存的作用。所以跟广大站长关系比较大的是授权 DNS，也就是在域名注册商处填写的 DNS 地址，而网民使用的则是递归 DNS。 
两种DNS劫持攻击方法： 
针对授权 DNS 劫持的攻击有两种方法，第一种是控制它在域名注册商处的帐号；第二种，入侵授权 DNS 的服务器，完全掌握授权 DNS，这个难度还是比较大的。 
针对递归 DNS 的 DNS 劫持攻击通常是地域性的，也就是说，黑客攻击了某一个或者某几个递归 DNS 服务器。所以只有使用了该递归 DNS 的网民受到影响。




UDP也要提供检查和校验。其原因是链路层以下的协议在源端和终端之间的某些通道可能不提供错误检测。虽然UDP提供有错误检测，但检测到错误时，UDP不做错误校正，只是简单地把损坏的消息段扔掉，或者给应用程序提供警告信息。



Connection:连接方式，Close表明为非持续连接方式，keep-alive表示持续连接方式。Cookie值是由服务器产生的，HTTP请求报文中有Cookie报头表示曾经访问过www.test.edu.cn服务器


HTTPS中的S代表security（安全），HTTPS和HTTP的区别在于HTTPS的传输采用了加密方式，web服务器申请了证书并与服务器绑定，传输更安全








主机甲和主机乙新建一个TCP 连接，甲的拥塞控制初始阈值为 32KB，甲向乙始终以 MSS=1KB 大小的段发送数据，并一直有数据发送；乙为该连接分配 16KB 接收缓存，并对每个数据段进行确认， 忽略段传输延迟。若乙收到的数据全部存入缓存，不被取走，则甲从连接建立成功时刻起，未发送超时 的情况下，经过 4 个 RTT 后，甲的发送窗口是（A）。
A.1KB
B.8KB
C.16KB
D.32KB
发送窗口大小取决于min(rwnd,cwnd).
其中rwnd是接收缓存的空余大小，表示接收方还能接收多少。
cwnd就是我们常常画慢增长曲线，拥塞避免曲线等等分析的纵轴数值。
这里，其实很明确的告诉我们接收缓存只进不出，因此在不断减小。可是我们有一个思维惯性是喜欢思考有趣的部分，画cwnd的变化，自以为这个分析好了问题就手到擒来了，切不可忽视rwnd。这里就是个例子。
cwnd从1MSS = 1KB开始，一个RTT后变为2KB，两个RTT后变为4KB,3RTT后变为8KB，4个RTT后变为16KB
同时呢，接收缓由16KB→15KB→13KB→9KB→1KB16KB→15KB→13KB→9KB→1KB
 	通知窗口值，代表接收缓存剩余值(KB)	拥塞窗口大小(KB)	发送窗口大小(KB)
初始	         16	          1	               1
经过第一个RTT	       16-1=15	          2	          min(15, 2)=2
经过第二个RTT	       15-2=13	          4	          min(13,4)=4
经过第三个RTT	       13-4=9	          8	          min(9,8)=8
经过第四个RTT	        9-8=1	         16	 通知接收缓存只有1KB了，发送窗口取min(1, 16)=1KB
 经过一个RTT，第二次发送时，rwnd = 15KB,cwnd = 2KB，发送窗口取较小值：2KB




//实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）
class Solution {
    public double quickMul(double x, long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }

    //public double myPow(double x, int n) {
//        return Math.pow(x,n);

//        double num = 1.0;
//        if (n < 0){
//            x = 1/x;
//        }
//        if (n > 0) {
//            while (n > 0) {
//                num *= x;
//                n--;
//            }
//        }else {
//            while (n < 0) {
//                num *= x;
//                n++;
//            }
//        }
//        return num;
    }
}
public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.myPow(2, -2));
    }

}

