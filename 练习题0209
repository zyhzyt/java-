在具有对换功能的操作系统中，通常把外存分为文件区和对换区。前者用于存放文件，后者用于存放从内存换出的进程。抖动现象是指刚刚被换出的页很快又要被访问为此，又要换出其他页，而该页又快被访问，如此频繁的置换页面，以致大部分时间都花在页面置换上。撤销部分进程可以减少所要用到的页面数，防止抖动。对换区大小和进程优先级都与抖动无关

页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动。
抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的页面频繁从内存调入调出。

读取数据速度最快的当然是缓存， 接着消耗时间最少的是内存， 磁盘寻道时间， 然后是硬盘连续读取时间
1.	L2缓存是level2缓存是二级缓存的意思， 通过缓存直接与cpu进行数据交互， 这个是最快最直接的。
这部分内容涉及到cpu缓存， 分为一级缓存，二级缓存，三级缓存。
一级缓存（L1 Cache）就是指cpu第一层级的高速缓存， 主要担当的工作是缓存指令和缓存数据。 一级缓存容量与结构对cpu的影响十分大， 但是由于它的结构比较复杂，又考虑到成本等因素， 一般来说，cpu的一级缓存较小， 通常cpu的一级缓存也就做到256kb左右的水平。
二级缓存（L2 Cache66）就是指cpu的第二层级的告诉缓存， 而二级缓存的容量会直接影响到cpu的性能， 二级缓存的容量越大越好。 例如intel的第八代i7-8700处理器， 共有六个核心数量， 而每个核心都拥有256kb的二级缓存， 属于各核心独享， 这样二级缓存总数就达到了1.5mb。
三级缓存（L3 Cache）就是指cpu的第三层级的告诉缓存， 其租用是进一步降低内存的延迟， 同时提升海量数据量计算时的性能。 和一级缓存，二级缓存不同的是， 三级缓存是核心共享的， 能够将容量做的很大。
2.	第二个，内存读取时间， 当通过缓存寻找数据时发现数据在缓存中不存在，这时需要通过到内存中去寻找， 但是内存的传输速度就没有缓存这么快了，所以，内存读取数据的时间消耗要大于缓存。
3.	第三个从硬盘连续读取1kb，这个意思就是读取硬盘数据， 其中读取硬盘数据的时间消耗主要是由寻道时间， 数据传输时间， 还有旋转时间三部分时间组成， 所以磁盘寻道时间一定小于总的此案读取时间






选择在最近的过去很久未访问的页面予以淘汰的算法称为(LRU) 。 
	OPT： 
Optimal page replacement algorithm 最佳页面替换算法。 
预测哪个页面最晚出现，就替换哪个页面。 
	LRU： 
Least Recently Used 不要译成“近期最少使用算法”， 
Recently Used是“最近使用”，Least为否定词，结果就是“最远使用”，建议翻译成“最久未被使用算法”。 
（很多翻译为“最近最久未被使用”，听起来也很怪，我感觉最近不用保留） 
	MFU： 
Most Frequently Used 最常使用算法， 
看这个字面意思是要替换掉“最常使用的页面”了…… 
	LFU： 
Least Frequently Used 不要翻译成“最近最不常使用算法”。 
Frequently Used 是经常使用，Least是否定词，可以翻译成“最不经常使用算法”，不知道最近是哪里来的？和MFU是相反的，替换掉最不经常使用的页面


在分页存储管理系统中，页面的大小是由计算机系统的地址结构所决定的，一般由软硬件共同决定。对于某一种系统一般采用一种大小的页面(也有部分现代操作系统采用双页面系统的)。在确定地址结构时，若选择的页面较小，一方面可使内碎片减小，并减少了内碎片的总空问，有利于提高内存利用率。另一方面，也会使每个进程要求较多的页面，从而导致页表过长，占用大量内存。此外还会降低页面换进换出的效率。若选择的页面较大，虽然可减少页表长度，提高换进换出效率，但却又会使页内碎片增大。由于内存的大小是固定的，所以无论页面是大是小，可以进入内存的作业大小也是固定的，最多不超过内存的大小。实际上，分页的大小并不影响进入内存作业的数量。从宏观上看，进入内存的页面内容是没有变化的。所以分页式虚拟存储管理系统中，页面的大小与可能产生的缺页中断次数关系并没有确定的关系。



应用层：报文 （message）
运输层：报文段 （Segment）
网络层：数据报  （ datagram ）
链路层：帧（ Frame ）
物理层：比特（bit）


在TCP/UDP传输段中，源端口地址和目的端口地址是不能相同的，否则就会建立自己到自己的连接，白白耗费资源。网络攻击中的LAND 攻击就是利用这个这一点进行攻击的。
源套接字：源端口号+源IP地址； 目的套接字：目的端口号+目的IP地址； 源套接字和目的套接字用于唯一的确定一条TCP连接。因此不能相同


计算机网络是由负责信息处理并向全网提供可用资源的资源子网和负责信息传输的通信子网组成


SNMP simple network management protocol 简单网络管理协议 
是一个网络管理员用来管理的工具相当于  一个app 所以是应用层


ICMP是IP协议不可分割的一部分,所以ICMP是属于网络层的一个协议.


图论的基本知识。首先5行，所以5个顶点，由握手定理可知，顶点的度数和等于2倍的边数，矩阵的各行和（或各列和）等于该顶点的度数，将矩阵的所有行（列）和相加得到的就是2倍的边数，所以共8条边

交换机攻击主要有以下5种类型： 
1.VLAN跳跃攻击 
2.生成树攻击 
3.MAC表洪水攻击 
4.ARP攻击 
5.VTP攻击 
DCHP攻击：利用了交换机端口安全功能，MAC动态地址锁和端口静态绑定MAC，来限定交换机某个端口上可以访问网络的MAC地址，从而进行控制。 
而目录遍历攻击是HTTP所存在的一个安全漏洞，它使得攻击者能够访问受限的目录，并在Web服务器的根目录以外执行命令。不属于交换机攻击。


POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。 是 TCP/IP 协议族中的一员 ，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。 
POP 协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或 MAC。一旦邮件发送到 PC 机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。






URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。 
URL的一般语法格式为： 
(带方括号[]的为可选项)： 
protocol :// hostname[:port] / path / [;parameters][?query]#fragment 
protocol（协议） 
指定使用的传输协议，下表列出 protocol 属性的有效方案名称。 最常用的是HTTP协议，它也是目前WWW中应用最广的协议。 
file 资源是本地计算机上的文件。格式file:///，注意后边应是三个斜杠。 
ftp 通过 FTP访问资源。格式 FTP:// 
gopher 通过 Gopher 协议访问该资源。 
http 通过 HTTP 访问该资源。 格式 HTTP:// 
https 通过安全的 HTTPS 访问该资源。 格式 HTTPS:// 
mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto: 
MMS 通过 支持MMS（流媒体）协议的播放该资源。（代表软件：Windows Media Player）格式 MMS:// 
ed2k 通过 支持ed2k（专用下载链接）协议的P2P软件访问该资源。（代表软件：电驴） 格式 ed2k:// 
Flashget 通过 支持Flashget:（专用下载链接）协议的P2P软件访问该资源。（代表软件：快车） 格式 Flashget:// 
thunder 通过 支持thunder（专用下载链接）协议的P2P软件访问该资源。（代表软件：迅雷） 格式 thunder:// 
news 通过 NNTP 访问该资源。 
hostname（主机名） 
是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。 
port（端口号） 
整数，可选，省略时使用方案的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80。如果输入时省略，则使用默认端口号。有时候出于安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL中就不能省略端口号这一项。 
path（路径） 
由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。 
parameters（参数） 
这是用于指定特殊参数的可选项。 
query(查询) 
可选，用于给***页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&”符号隔开，每个参数的名和值用“=”符号隔开。 
fragment（信息片断） 
字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。





HTTP请求消息
1、客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。
2、一个完整的HTTP请求包括如下内容：一个请求行、若干消息头、以及请求正文，其中的一些消息头和正文都是可选的，消息头和正文内容之间要用空行隔开。
HTTP响应消息
1、一个HTTP响应代表服务器向客户端回送的数据。
2、一个完整的HTTP响应包括如下内容：
一个状态行、若干消息头、以及响应正文，其中的一些消息头和正文都是可选的，消息头和正文内容之间要用空行隔开。
http请求头
 http请求头简介：请求头字段用于客户端在请求消息中向服务器传递附加信息，主要包括客户端可以接受的数据类型、压缩方法、语言以及发出请求的超链接所属页面的URL地址等信息。常用请求头：
a)     Accept:浏览器可接受的MIME类型
b)   Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集
c)   Accept-Encoding:浏览器能够进行解码的数据编码方式，比如gzip
d)   Accept-Language:浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。可以在浏览器中进行设置。
e)   Host:初始URL中的主机和端口
f) Referer:包含一个URL，用户从该URL代表的页面出发访问当前请求的页面
g)  Content-Type:内容类型
h)   If-Modified-Since: Wed, 02 Feb2011 12:04:56 GMT利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件。
i)   User-Agent:浏览器类型.
j)   Content-Length:表示请求消息正文的长度
k)  Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接
l) Cookie:这是最重要的请求头信息之一    6m) Date：Date: Mon,22 Aug 2011 01:55:39 GMT请求时间GMT



import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        String[] str = new String[n];
        for(int i = 0; i < n; i++){
            String[] s = in.nextLine().split(" ");
            
        }
    }
    public static void main1(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] num = new int[n];
        for(int i = 0; i < n; i++){
            num[i] = in.nextInt();
        }
        int K = in.nextInt();
        int D = in.nextInt();
        long[][] dpm = new long[K+1][n+1];//dpm[i][j]表示选中了i个人，以第j个人结尾的能力最大乘积
        long[][] dpn = new long[K+1][n+1];//dpn[i][j]表示选中了i个人，以第j个人结尾的能力最小乘积
        for(int j=1; j<n+1; j++){//初始
            dpm[1][j] = num[j];
            dpn[1][j] = num[j];
        }
        for(int i=1; i<K+1; i++){//初始
            dpm[i][1] = num[1];
            dpn[i][1] = num[1];
        }
        for(int i=2;i<K+1;i++){
            for(int j=2;j<n+1;j++){
                for(int k=Math.max(1,j-D);k<j;k++){
                    dpm[i][j] = Math.max(dpm[i][j],Math.max(dpm[i-1][k]*num[j],dpn[i-1][k]*num[j]));
                    dpn[i][j] = Math.min(dpn[i][j],Math.min(dpm[i-1][k]*num[j],dpn[i-1][k]*num[j]));
                }
            }
        }
        long max = Math.max(dpm[K][1],dpn[K][1]);
        for(int j=2;j<n+1;j++){
            max = Math.max(Math.max(dpm[K][j],dpn[K][j]),max);
        }
        System.out.println(max);
    }



}



import java.util.Arrays;

class MaxGap {
    public int findMaxGap(int[] A, int n) {
        // write code here
        int max = A[0];
        for(int i = 1;i < n;i++){
            if(A[i] > max){
                max = A[i];
            }
        }
        int min = Math.min(A[0],A[n-1]);
        return max-min;
    }
}

public class Main {

}
